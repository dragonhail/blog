---
title: 프로세스
linkTitle: 프로세스
weight: 
layout: wide
cascade:
  type: docs
sidebar:
  open: true
---

## Process
### 개요
- 실행 중인 프로그램
- 리눅스는 다중 프로세스 시스템
- 프로세스는 부모-자식 관계를 가지고 생성
- 프로세스 구분 방법 중 하나로 시스템 프로세스(운영체제가 생성)와 사용자 프로세스로 나누기도 함
- 리눅스가 부팅이 될 때 systemd 프로세스와 kthreadd 프로세스 생성, 이 프로세스 제외한 모든 프로세스는 부모 프로세스 존재
- 자식 프로세스는 부모 프로세스에 의해 만들어지고 자식 프로세스는 자신의 작업이 종료되면 부모 프로세스에게 결과를 돌려주고 종료됨
- 결과는 정상 수행이나 에러로 인한 종료를 구분하기 위한 값
- 로그인을 해서 bash shell을 실행하고 그 안에서 vi편집기를 실행하면 이 경우는 vi 프로세스가 자식 프로세스가 되고 bash shell이 부모 프로세스가 됨
- vi편집기 종료하면 결과를 bash shell에게 전달하고 종료됨

### 프로세스 번호
- 프로세스는 만들어질 때 관리의 편리성을 위해 고유번호 부여 PID(Process Identification Number)
- 이름 사용하지 않고 번호 사용하는 이유는 하나의 프로그램을 동시에 여러번 실행할 수 있기 때문에 일반적으로 네이밍 방법으로는 구분하기 어려움
- PID는 1번부터 일련번호 형태로 부여됨
- 부팅될 때 실행되는 systemd가 1번이고 kthreadd가 2번으로 생성, 나머지 프로세스는 이들의 자식
- 유닉스에서는 init 프로세스가 1번이었지만 우분투는 init의 이름을 systemd로 변경

### 프로세스 종류
- 리눅스의 프로세스 중 사용자가 실행한 경우에는 잠깐 실행되었다가 종료
- Daemon Process
  - 특정 서비스를 계속 제공하기 위해 존재
  - 커널에 의해서 실행
  - 평소에는 대기 상태로 있다가 요청이 오면 서비스를 제공
  - 서버에서 구동되는 프로세스들이 여기에 해당되는 경우가 많음

- Orphan Process
  - 자식 프로세스는 부모 프로세스가 종료되면 같이 종료가 되어야 하는데 부모 프로세스는 종료되었는데 종료되지 않고 남아있는 프로세스
  - 1번 프로세스가 새로운 프로세스가 됨
  
- Zombie Process
  - 자식 프로세스가 종료될 때 자신이 종료되었다는 사실을 부모 프로세스에게 알려주고 종료되는데 프로세스는 종료가 되었는데 부모 프로세스의 자식 프로세스 테이블에는 남아있는 형태
  - 자식 프로세스의 종료를 부모 프로세스가 제대로 처리를 하지 못해서 발생하게 되는데 프로세스 목록에서는 defunct라고 표시
  - 부모 프로세스는 자식 프로세스를 테이블 형태로 관리하는데 테이블의 용량이 유한
    테이블의 용량이 다 차면 더 이상 프로세스 생성 불가
  - 좀비는 실체가 없어서 kill 명령으로 종료 안됨, 부모 프로세스를 종료하거나 SIGCHLD 시그널을 부모 프로세스에게 보내서 좀비 프로세스를 찾아서 정리하도록 해야함
  - SIGCHLD 시그널을 보내면 이 프로세스를 고아 프로세스로 만들고 1번 프로세스가 부모 프로세스가 되고 일정 시간 단위로 1번 프로세스가 조회를 해서 제거

### 프로세스 목록 확인
- ps
  - ps [옵션]
    e: 모든 프로세스 정보 출력
    f: 프로세스에 대한 자세한 정보 출력
    u uid: 유저가 실행한 프로세스
    p pid: 프로세스 id에 해당하는 프로세스의 정보를 출력
    a: 터미널에서 실행한 모든 프로세스 정보를 출력
    u: 자세히 출력
    x: 시스템에서 실행한 모든 프로세스 출력
- 프로세스 검색 ```ps -ef | grep bash```