---
title: Linux
linkTitle: Linux
weight: 4
layout: wide
cascade:
  type: docs
sidebar:
  open: true
---
## 명령어
### 종료
```bash
poweroff
shutdown -P now #지금 종료
shutdown -P +10 #10분후 종료
shutdown -r 22:00 #22시 재부팅
shutdown -c #예약된 종료 취소
shutdown -k +15 #현재 접속한 사용자에게 15분후 종료한다는 메시지 전송, 실제로는 종료되지 않음
halt -p
init 0
```

### 재부팅
```bash
shutdown -r
reboot
init 6
```

### 로그아웃
* 관리자가 시스템 종료를 하면 접속된 모든 유저의 연결 해제
* 관리자가 접속을 해제하고자 하는 경우 logout이나 exit명령을 이용해서 로그아웃

### init
* run레벨을 의미
```shell
init 0 # 종료
init 1 # 복구 모드로 한 명의 사용자만 접속 가능
init 6 # 재부팅
```
### 명령어 사용법
* SHELL: 명령어 해석기. 터미널이나 원격접속툴에서 명령을 내리면 SHELL이 번역을 해서 kernel에 전달하고 실제 명령이 수행됨
* 기능: 
  * 명령어해석기
  * 프로그래밍
  * 사용자환경설정: shell은 사용자 환경을 설정할 수 있도록 초기화 파일 제공<br>
  전체 설정 파일을 읽은 후 사용자 환경 설정 파일을 읽어서 사용자 별로 환경을 구성
* shell에 보여지는 문자열-프롬프트
  ```shell
  사용자이름@호스트이름(컴퓨터):~$
  슈퍼사용자일 경우 사용자이름@호스트이름(컴퓨터):~#
  ```
  * 로그인 할 때 하나의 shell이 보여지게 됨. 이 shell을 로그인 shell이라함
  * 현재 사용중인 shell 확인하는 명령
  ```shell
  echo $SHELL
  ```
  * ~: 홈디렉토리
* 명령어 입력 시 에러가 발생한 경우
  * 키보드 입력이 안될 시 CTRL + s를 눌러 잠금을 한 경우: CTRL + q를 눌러 잠금해제
  * 명령이 종료되지 않은 경우: CTRL + c 눌러 현재 실행중 프로세스 강제 종료
  * 실수로 텍스트파일이 아닌 파일을 열어 한글이 깨지는 경우: CTRL + l(clear)을 눌러 화면 클리어

* 명령어의 구조는 기본적으로 명령 [옵션] [인자]
* 명령은 실행 프로그램 또는 내장 명령어
* 옵션은 -또는--
  * -다음에는 한글자
  * --다음에는 단어
* 옵션은 대부분의 경우 순서에 상관없이 여러개 입력 가능
* 한글자인 경우 결합가능

```shell
ls -a 또는 ls --all
ls -a -l -> ls -al # 결합 가능
docker -dit -> docker -d -i -t # d=background, i=interactive, t=terminal
```

### 명령어 자동완성
* 입력 중 입력 한 단어로 시작하는 명령이 하나만 존재한다면 tab을 누르면 명령어는 자동완성이 됨. <br>
입력 중 입력한 단어로 시작하는 명령이 여러 개 존재한다면 tab을 한 번 더 누르면 모든 명령 출력

### 명령어 입력방식
* 텍스트파일에 만들어두고 이 파일의 내용을 읽어서 수행: 스크립트 방식이라고 하고 파일의 확장자는 sh

### 히스토리 기능
* 이전에 수행했던 명령어를 저장
* 키보드화살표 사용 또는 CTRL + p, CTRL + n명령 이용
* CTRL + r을 이용하면 증분 모드로 검색 가능
* history라고 입력 시 수행한 모든 명령어 출력
```shell
history
```
* more로 파일내용
```shell
more 파일명
```
### 옵션
* !!: 직전 명령어 수행
* !번호: 번호에 해당하는 명령어 수행
* !문자열: 문자열로 시작하는 마지막 명령어를 수행
* history -d 라인번호: 라인번호에 해당하는 명령어 삭제
* history -c: 모든 명령어를 삭제

* history내용은 홈 디렉토리의 .bash_history파일에 저장되어 있음
* .파일명 -> 숨김파일

### 명령어 도움말
* 명령어 --help
* man이라는 명령어도 도움말을 출력
```shell
man [옵션] [섹션] 명령
```
* shell이 명령어 찾는 위치 - 환경변수 path
* 현재 디렉토리에서 명령을 찾고 없으면 PATH에서 찾고 그래도 없으면 shell내장 명령 수행
```shell
echo $PATH
```
* 명령어의 절대 경로 찾기: whereis [옵션][명령어 - 실행(바이너리) 파일]
* 스케줄링 같은 것을 할 때는 명령어의 절대 경로를 기반으로 수행
* 내장 명령의 경우는 별 문제가 안되지만 내장 명령이 아닌 경우는 절대경로를 알아야함
* 옵션
  * -b: 바이너리 파일만 검색
  * -m: 메뉴얼 파일만 검색
  * -s: 소스 파일만 검색
  ```shell 
  whereis -m ls
  ```
  * which는 명령어를 찾을 때 PATH에서만 찾음
  * a나 i옵션을 이용하는 경우가 있음
* 기타 명령어
  * passwd: 비밀번호 변경
  * exit: 현재사용중인 SHELL종료, 로그인SHELL에서 다른SHELL 실행한 경우는 이전에 실행한 SHELL로 이동
  * clear: 현재 화면 삭제 - CTRL + l

### SSH
```shell
sudo apt-get update
sudo apt-get install openssh-server
sudo systemctl status ssh
sudo ufw allow ssh
```

* 패키지관리자 - central repository의 프로그램/패키지 저장 위한 db <br>
->접속하면 로컬에 DB 가져옴 <br>
->프로그램 업데이트 시 로컬도 업데이트 시켜야->apt-get update <br>
* sudo->관리자 권한
* firewall: inbound제어 못들어오게

* proxy서버: outbound제어
* 유저에 관리자 권한이 없으면 위의 명령이 수행안될 수 있음
```shell
sudo usermod -aG sudo 계정명  # 계정 관리자 권한 설정
```

### 포트포워딩
* 내부의 IP와 외부IP를 매핑해서 내부에서 사설 IP를 사용하지만 외부 IP를 이용해서 인터넷을 할 수 있도록 해주고 외부에서는 설정한 외부IP를 이용해 내부IP를 가진 컴퓨터에 접근할 수 있도록 해줌
* 리눅스에서 사설 IP 조회, 터미널 실행시켜 hostname -i 명령 수행 (ifconfig 명령은 net-tools 설치해야) (Default 주소는 10.0.2.15)
* 터미널이 실행이 안될 때는 [설정] - [Region & Language] 에서 캐나다로 변경하고 로그아웃 후 다시 로그인
* 윈도우즈에서 공인 IP 조회: ipconfig /all<br>
실제 사용하는 어댑터의 IP주소 확인 (인터넷 어댑터 이더넷 2)
* virtual box의 [머신] - [설정] - [고급] - [포트포워딩] 선택 후 룰 추가<br>
포트번호: 22, 호스트IP: 윈도우즈IP, 게스트IP: 리눅스사설IP, 포트번호: 22
* ssh 계정@호스트IP -p 포트번호 으로 접속
* 리눅스 계정 전환
```shell
sudo # 일시적으로 관리자 권한 부여 superuser do
sudo su
su root
su -root # 관리자로 전환
su [계정명] # 특정계정으로 전환
```

### alias
* 별칭 부여
```shell
alias 별명 = '설정값'
unalias # 별명 해제
```
* 어떤 명령이 별명인지 확인하고자 할 때는 type 명령을 입력했을 때 명령이라면 명령 위치 출력, 별명이라면 원본 위치 출력
* ex
```shell
alias ls='ls -F' # alias 설정
unalias ls # 해제
```
* type ls: 별명이라서 명령의 위치가 나오지 않고 별명이라고 출력
* type cp: 별명이 아니라서실제 위치가 출력
  
### 별명이 설정되어 있을 때 원본 명령어를 실행
* 전체 경로로 명령어를 입력(명령어 위치를 whereis나 which 사용)
* command 명령어나 \명령어를 입력

### 날짜 및 시간 명령
* date: 시스템에서 설정되어 있는 현재 시각과 날짜를 출력
* timedatectl: 하드웨어 및 소프트웨어에 설정된 모든 시간과 날짜를 출력

### 시스템 사용자 정보
* logname: 로그인네임
* users: 접속한 사용자 이름
* who: 로그인 한 모든 사용자 계정
* whoami: 현재 사용자

### 시스템 정보 확인
* uname [옵션] <br>
-a: 시스템의 모든 정보 확인<br>
-m: 시스템이 사용 중인 하드웨어 정보 확인<br>
-n: 호스트 네임 확인 - 컴퓨터 이름<br>
-r: 운영체제 릴리즈 번호<br>
-s: 운영체제 이름 <br>
-v: 버전 출시 일자 <br>
* hostname: 현재 사용중인 컴퓨터 이름, 옵션 이용해 IP 확인가능
* arch: CPU 정보
* env: 환경변수 확인

### sudo와 su
* sudo: 일시적으로 관리자 권한으로 실행<br>
패키지 관련 명령이나 환경설정파일 수정할 때 관리자 권한 요청
* su 계정: 현재 계정의 환경변수 유지하면서 다른 계정으로 전환
* su - 계정: 다른 사용자의 계정으로 전환할 때 *환경변수*도 전환
* su: *관리자 계정*으로 전환

### 편집기
* 행단위편집기: ed, ex, sed
* 화면단위편집기: vi(vim), emacs, nano(메뉴기반)
* GUI편집기: gedit
* 모드형 편집기: 입력모드와 명령모드 구분<br>
vi가 대표적인 모드형 편집기
* 비모드형 편집기: 입력모드와 명령모드가 구분되어있지 않음<br>
명령은 CTRL이나 ALT 등과 다른 키를 조합해서 수행<br>
nano가 대표적인 비모드형 편집기

## vim
* vi 이후 개발된 편집기
* vim이라는 이름으로 시작할 수 있고 vi라고 입력해도 vim이 입력됨
* vim 설치->sudo apt-get install vim
* DOCKER 사용 시 설정 파일 수정하려면 호스트OS에서 파일 수정 후 볼륨기능<br>
이용해 파일 복사하는 방법 vs DOCKER 쉘 안에서 직접 편집하는 방법<br>
쉘 안에서 직접 편집하려면 편집기가 설치되어 있지 않아 직접 설치하고 수정해야

### vim 동작모드
* 명령 모드: 커서이동, 페이지이동, 글자삭제, 행삭제
명령 모드에서 입력 모드로 전환은 i, l, o, O, a, A
* 입력 모드: 텍스트입력
  * 입력 모드에서 명령 모드로 전환은 ESC
  * 명령 모드에서 마지막 행 모드로의 전환은 : / ?
  * 마지막 행 모드에서 명령 모드로의 전환은 ESC나 ENTER
  * 명령 모드에서 저장하고 종료는 :wq나 :wq!
  * 명령 모드에서 저장하지 않고 종료는 :q나 :q!
  * 명령 모드에서 종료는 ZZ
* 마지막 행 모드: 검색, 바꾸기

### vim 시작
```shell
vim 파일경로
```
* 파일이 없으면 새로 만들어지는데 저장을 해야 파일이 생성
* 저장하지 않으면 생성 안됨
* 파일이 존재하는 경우 열리게 되는데 수정 권한이 없으면 읽기 전용으로 열림

### 입력 모드 전환 시 i, a, o의 차이
* i는 현재 위치 삽입
* a는 다음 칸에 삽입
* o는 아래 줄에 삽입

### 커서 이동 단축키: 명령모드에서 실행
* $ 현재 행 마지막으로 이동
* \- 현재 행 맨 앞으로 이동
* H 첫번째 행으로 이동
* M 중간 행으로 이동
* L 마지막 행으로 이동

### 원하는 행으로 바로 이동
* 숫자G: 숫자행으로 이동
* 숫자 엔터: 숫자 행으로 이동

### 내용 검색 (중요)
* 텍스트 파일 내용 많을 때 원하는 곳으로 이동
* 마지막 행 모드에서 수행(입력 모드에서 ESC를 눌러서 수행)
* /문자열: 문자열을 아래 방향으로 검색
* ?문자열: 문자열을 위 방향으로 검색
* n: 원래 찾던 방향으로 다음 문자열을 검색
* N: 반대 방향으로 다음 문자열을

### 파일 읽어오기
```shell
:r 파일경로 # 파일을 읽어서 현재 위치에 추가
:e 파일경로 # 지정한 파일로 전환(:w명령으로 저장한 후 수행)
:n # 여러 파일을 한꺼번에 연 경우 다음 파일로 전환
```

### 문서 작성 중 쉘 명령 수행
```shell
:!쉘명령 # vi작접 잠시 중단 후 쉘 명령 수행, vi로 돌아올 땐 ENTER
:sh # vi 잠시 빠져나가 쉘 명령 수행, vi로 돌아올 때 exit
```

### vi 환경 설정 (중요)
* 사용자 홈 디렉토리에 .exrc 파일에 설정 내용을 저장, 모든 파일에 적용 - 재부팅을 해주거나 source 명령을사용
* 환경변수와 설정파일에 동일한 내용 작성 차이: 설정 파일은 로그인 할때 읽어서 설정, 환경 변수는 프로그램 실행할 떄 읽어서 적용
```shell
vi ~/.exrc
```
* 환경변수 중 EXINIT에 지정
```shell
EXINIT='set nu'
export EXINIT
```
* vi의 마지막 행 모드에서 명령으로 설정: 현재 작업 중인 파일에만 적용
```shell
set nu # 라인번호 출력
set list # 눈에 보이지 않는 특수문자 출력
set showmode # 현재 모드를 출력
set ai # 윗 라인과 들여쓰기를 맞춰줌
set si # 코딩할 때 if 나 for 같은 블럭 명령어를 사용하면 다음 라인으로 이동할 떄 들여쓰기
set paste # 붙여넣기를 발생하는 계단 현상 방지
set ts=숫자 # 탭의 간격 설정
set ic # 검색할 때 대소문자 구분않음
set no # 설정해제
```
## SHELL
### 개요
* 사용자가 입력한 명령을 해석해서 커널로 전달하거나 커널의 처리 결과를 사용자에게 전달하는 역할을 수행하는 구성 요소
* OS: hw -> kernel -> shell -> util, application
* server의 텍스트 모드나 GNOME의 터미널을 이용해 명령어를 입력하고 결과를 화면에 출력

### 기능
* 명령어 해석기
* 프로그래밍
* 사용자 환경설정

### 종류
* bourneshell: 초창기의 쉘, 현재 사용X
* C shell
* Korn shell
* bash: C shell과 Korn shell 장점 혼합, 현재 리눅스 기본 shell
* 현재 리눅스 기본 쉘: tsch, dash, zsh

### bash 쉘 특징
* alias 기능 제공
* history 기능 제공
* 명령어 자동완성 기능 제공
* 연산 기능 제공
* Job control 기능 제공

### 쉘 변경
* 지원하는 쉘 확인
```shell
cat /etc/shells
```
* 사용자의 로그인 쉘 확인
```shell
grep 사용자계정 /etc/passwd
```
* C shell 설치
```shell
sudo apt-get install csh
```
* 로그인 쉘 변경
```shell
chsh 옵션 쉘의경로 사용자계정 # 쉘의경로는 절대경로
chsh -s /usr/bin/csh dh # C shell로 변경
chsh -s /usr/bin/dash dh # dash shell로 변경
```
  * C shell 예전 설치 시 /bin/csh에 설치 -> 지금은 /usr/bin/csh에 설치
  * 충돌 방지 위해 예전 경로와 지금 경로 바로가기 연결
  * source파일: 코드, 바이너리파일: 컴파일, 매뉴얼파일: 묶어놈
  * dash 쉘은 프롬프트가 $이고 bash쉘은 유저이름과 호스트이름이 같이 출력
  * C shell로 변경 시 프롬프트가 #으로 변경

* 서브 쉘 생성
  * exit하면 이전쉘로 돌아감
```shell
쉘이름 -s sh 사용자계정
```
* 현재 사용자 쉘 확인
```shell
echo $SHELL
```
* 로그아웃
```shell
exit
```

### 쉘 내장 명령
* 별도의 실행 파일을 가지지 않고 쉘이 내장하고 있는 명령어
* 쉘 별로 이 명령어가 다를 수 있음
* pwd는 쉘 내장명령이 아니고 cd는 쉘 내장명령임
* echo 변수나 문자열을 출력
```shell
echo [-n] 문자열 또는 변수 # -n은 출력하고 마지막에 줄바꿈 않음
```
* shell에서 변수는 앞에 $가 붙음
* printf C언어의 printf와 동일
  * %로 시작하는 형식하된 서식 사용가능
  * 내장하고 있는 쉘도 있고 없는 쉘도 있음 
 ```shell
  printf "%d + %d = %d\n" 100 200 300
 ```

### 특수문자
* 쉘에서는 사용자가 편리하게 명령을 입력하고 실행할 수 있도록 특수문자를 제공
* 거의 모드 쉘에서 특수문자의 기능은 동일
* \* 
  * 임의의 문자열을 의미, 글자수와 상관없이 매핑
  * ls \* 현재 디렉토리 및 서브디렉토리 내용 모두 출력
  * \*.txt, cp \*, t\*.
* ?
  * 한 글자
  * SQL: %->* _->?
* [ ]
  * 여러 개 중 한글자 선택할 때
  * \-를 이용해 범위 설정 가능
  * 범위는 코드값을 기준으로 함
  * 숫자 0은 48, 9는 57, A는 65, Z는 90, a는 97, z는 122
  * A-Z: 대문자, a-z: 소문자, 0-9: 숫자, 가-힣: 한글, a-zA-z: 영문자
  * 현대 디렉토리에서 대문자로 시작하는 파일만 /tmp로 복사
* ~
  * 사용자 홈 디렉토리
* \-
  * 현대 디렉토리로 이동하기 전의 디렉토리
* `
  * 문자열에서 백틱으로 명령을 묶으면 명령을 수행해서 문자열 안에 포함
 ```shell
 echo "Today is `date`"
 Today is Tue Sep  3 15:41:44 KST 2024
 ```
* ;
  * 여러 개의 명령을 사용할 때 순서대로 실행하고자 하는 경우 사용
 ```shell
 date;ls;
 ```
* |
  * 앞 명령의 결과를 뒤 명령에 전달해서 수행
  * 루트 디렉토리의 모든 내용을 출력해서 페이지 단위로 확인
 ```shell
 ls -al / | cat
 ```
* \
  * 에스케이프
  * 특수문자를 포함하는 데이터를 ''로 묶어도 특수문자 기능 무시
  * ""로 묶으면 $;\,{},[]는 원래대로 처리하고 나머지 무시

### 입출력 리다이렉션
* 표준입출력
  * 표준 입력은 일반적으로 키보드 입력
  * 표준 출력은 모니터를 의미

* 리다이렉션
  * 입출력의 방향을 변경
  * 파일로 변경

* \>
  * 출력을 뒤에 있는 장치(리눅스는 하드웨어도 파일로 간주)로 변경
  * 출력하는 장치를 매번 새로만듬
* \>\>
  * 출력을 뒤에 있는 장치(리눅스는 하드웨어도 파일로 간주)로 변경
  * 출력하는 장치 뒤에 추가
  * \>, \>\> 는 출력의 결과를 특정 파일에 기록하기 위해 사용
* 에러 출력 리다이렉션
  * 명령 다음에 2를 추가하고 출력 리다이렉션을 이용하면 표준
 ```shell
 ls /abc 2> ls.err
 ```

 ### 입력 리다이렉션
 * 명령어에 파일의 내용을 추가하고자 할 때 사용
 * 자주 사용하는 옵션이나 인자가 있을 때 활용 가능
 * < 파일경로

 ## 쉘 변수
 ### 지역변수
 * 현재 쉘에만 사용 가능한 변수
 
 ### 환경변수
* 시스템 전체에서 사용 가능한 변수

### 변수 확인
* set: 모든 변수와 함수를 조회
* env: 환경 변수만 조횧
* echo $변수: 변수의 값 출력

### 변수 생성 및 수정
* 변수명=값
* 있으면 수정, 없으면 생성
* 지역 변수를 환경 변수로 수정 export 사용
* 환경변수 지역변수로 수정: export -n 변수명

* unset 변수명
  * 변수삭제
* 변수에 내용 추가
  * 변수명=$변수명:내용
* 환경 변수를 전역에 등록
  * 사용자의 홈 디렉토리의 .bashrc 파일에 환경 변수를 등록해두면 재부팅 할 떄도 환경 변수의 값을 사용 가능
  * 사용자 홈 디렉토리의 .bashrc는 사용자가 로그인 할 때 읽어서 설정을 하는 파일
  * alias나 export를 이용해서 환경변수 만들면 로그인 할 때마다 적용
  * 일반 환경변수를 만들면 다른 곳에서 사용할 수 있도록 만들어지지만 재부팅을 하면 내용이 소멸
  * 재부팅을해도 내용을 유지시키려면 .bashrc파일에 등록을 해야 함

### 쉘 변수 사용
* 내장 명령어는 쉘 변수 사용 가능하지만 외부 명령어는 쉘 변수 사용 불가
* 리눅스 버전에 따라서는 외부 명령어에서 쉘 변수를 사용 가능하도록 해주는 것도 있음, 최신 버전의 리눅스에서는 외부 명령어에서도 쉘 변수 사용이 가능
 ```shell
 DIR=/tmp
 cd $DIR
 /tmp$
 ```

* 제공하는 환경 변수
  * PATH: 실행 파일(명령어)를 찾는 위치
  * PWD: 현재 작업 디렉토리의 절대 경로

### 환경 설정 파일
* 시스템 환경 설정 파일->/etc 디렉토리에 존재
* 종류
```shell
/etc/profile # 모든 쉘에 공통으로 적용되는 환경설정파일
/etc/bash.bashrc # 공통으로 적용되는 bashrc
/etc/profile.d/*.sh # 언어나 명령별로 각각 필요한 환경을 설정
```

### 유저별 환경 설정 파일
* 유저의 홈디렉토리에 존재(~, /home/계정)
* 종류
```shell
~/.profile # .bashrc가 있는 경우에만 수행되는데 사용자가 정의한 환경설정파일
~/.bashrc # 히스토리크기나 환경변수 또는 별명이나 함수
~/.bash_logout # 로그아웃 할 때 수행할 내용
~/.bash_aliases # 별명설정
```

### 읽는 순서
* 시스템이 부팅될 때 시스템 환경 설정 파일을 읽어서 설정을 하고 사용자가 로그인을 하면 사용자의 환경설정 파일을 읽어서 환경 설정 수정을 한 상태로 로그인
* 로그인을 한 후 환경 설정을 변경하면 변경한 환경 설정이 적용

### 적용
* 시스템을 재부팅하거나 로그인을 다시 하면 적용되는데 *재부팅이나 로그인을 하지 않고* 적용하고자 하는 경우는 source 환경설정파일경로 명령을 수행
```shell
source ~/.bash_aliases
source ~/.bash_logout
```
### 덮어쓰기 방지
* 기존의 파일이 존재하는 경우 덮어쓰지 않도록 설정
```shell
set -o noclobber # 덮어쓰기 방지
set +o noclobber # 해제
```

## 파일 시스템
* 유닉스나 리눅스에서 시스템과 관련된 정보와 하드웨어 같은 장치를 모두 파일로 관리
* 파일은 운영체제가 관리
* 프로그램에서 파일을 생성했더라도 파일 관리는 운영체제가 함
* 프로그래밍을 할 때 외부 자원을 사용하는 경우는 특별한 경우가 아니면 예외처리를 해줘야 함
* 외부 자원에 해당하는 것들은 파일, 네트워크, 데이터베이스가 대표적
* 리눅스는 물리적으로 여러 개의 하드디스크를 사용하더라도 하나의 루트 디렉토리를 가짐
* 디렉토리와 장치도 하나의 파일로 간주
* 계층적 디렉토리 구조

### 파일 종류
* 일반 파일
  * 일반적인 파일: 문서파일, 바이너리파일, 기타파일
* 디렉토리: 파일을 구조적으로 관리하기 위해 사용위한 파일
* 링크: 복제본이나 바로가기를 위한 파일
  * 하드링크: 복제본
  * 소프트링크: 바로가기
* 장치: 하드디스크나 키보드같은 장치를 관리하기 위한 파일
  * 대부분 /dev 디렉토리에 존재
* 파일 종류 확인: file 명령으로 확인 가능
```shell
file .profile
file Downloads
file /bin/bash
```